{"changed":false,"filter":false,"title":"http.js","tooltip":"http.js","value":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar net = require('net');\nvar Stream = require('stream');\nvar timers = require('timers');\nvar url = require('url');\nvar EventEmitter = require('events').EventEmitter;\nvar FreeList = require('freelist').FreeList;\nvar HTTPParser = process.binding('http_parser').HTTPParser;\nvar assert = require('assert').ok;\n\nvar debug;\nif (process.env.NODE_DEBUG && /http/.test(process.env.NODE_DEBUG)) {\n  debug = function(x) { console.error('HTTP: %s', x); };\n} else {\n  debug = function() { };\n}\n\nfunction readStart(socket) {\n  if (!socket || !socket._handle || !socket._handle.readStart || socket._paused)\n    return;\n  socket._handle.readStart();\n}\n\nfunction readStop(socket) {\n  if (!socket || !socket._handle || !socket._handle.readStop) return;\n  socket._handle.readStop();\n}\n\n// Only called in the slow case where slow means\n// that the request headers were either fragmented\n// across multiple TCP packets or too large to be\n// processed in a single run. This method is also\n// called to process trailing HTTP headers.\nfunction parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n}\n\n// info.headers and info.url are set only if .onHeaders()\n// has not been called for this request.\n//\n// info.url is not set for response parsers but that's not\n// applicable here since all our parsers are request parsers.\nfunction parserOnHeadersComplete(info) {\n  var parser = this;\n  var headers = info.headers;\n  var url = info.url;\n\n  if (!headers) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (!url) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  parser.incoming = new IncomingMessage(parser.socket);\n  parser.incoming.httpVersionMajor = info.versionMajor;\n  parser.incoming.httpVersionMinor = info.versionMinor;\n  parser.incoming.httpVersion = info.versionMajor + '.' + info.versionMinor;\n  parser.incoming.url = url;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 - assume that there're no limit\n  if (parser.maxHeaderPairs > 0) {\n    n = Math.min(n, parser.maxHeaderPairs);\n  }\n\n  for (var i = 0; i < n; i += 2) {\n    var k = headers[i];\n    var v = headers[i + 1];\n    parser.incoming._addHeaderLine(k, v);\n  }\n\n\n  if (info.method) {\n    // server only\n    parser.incoming.method = info.method;\n  } else {\n    // client only\n    parser.incoming.statusCode = info.statusCode;\n    // CHECKME dead code? we're always a request parser\n  }\n\n  parser.incoming.upgrade = info.upgrade;\n\n  var skipBody = false; // response to HEAD or CONNECT\n\n  if (!info.upgrade) {\n    // For upgraded connections and CONNECT method request,\n    // we'll emit this after parser.execute\n    // so that we can capture the first part of the new protocol\n    skipBody = parser.onIncoming(parser.incoming, info.shouldKeepAlive);\n  }\n\n  return skipBody;\n}\n\n// XXX This is a mess.\n// TODO: http.Parser should be a Writable emits request/response events.\nfunction parserOnBody(b, start, len) {\n  var parser = this;\n  var stream = parser.incoming;\n\n  // if the stream has already been removed, then drop it.\n  if (!stream)\n    return;\n\n  var socket = stream.socket;\n\n  // pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(socket);\n  }\n}\n\nfunction parserOnMessageComplete() {\n  var parser = this;\n  var stream = parser.incoming;\n\n  if (stream) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    var headers = parser._headers;\n    if (headers) {\n      for (var i = 0, n = headers.length; i < n; i += 2) {\n        var k = headers[i];\n        var v = headers[i + 1];\n        parser.incoming._addHeaderLine(k, v);\n      }\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    if (!stream.upgrade)\n      // For upgraded connections, also emit this after parser.execute\n      stream.push(null);\n  }\n\n  if (stream && !parser.incoming._pendings.length) {\n    // For emit end event\n    stream.push(null);\n  }\n\n  // force to read the next incoming message\n  readStart(parser.socket);\n}\n\n\nvar parsers = new FreeList('parsers', 1000, function() {\n  var parser = new HTTPParser(HTTPParser.REQUEST);\n\n  parser._headers = [];\n  parser._url = '';\n\n  // Only called in the slow case where slow means\n  // that the request headers were either fragmented\n  // across multiple TCP packets or too large to be\n  // processed in a single run. This method is also\n  // called to process trailing HTTP headers.\n  parser.onHeaders = parserOnHeaders;\n  parser.onHeadersComplete = parserOnHeadersComplete;\n  parser.onBody = parserOnBody;\n  parser.onMessageComplete = parserOnMessageComplete;\n\n  return parser;\n});\nexports.parsers = parsers;\n\n\nvar CRLF = '\\r\\n';\nvar STATUS_CODES = exports.STATUS_CODES = {\n  100 : 'Continue',\n  101 : 'Switching Protocols',\n  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n  200 : 'OK',\n  201 : 'Created',\n  202 : 'Accepted',\n  203 : 'Non-Authoritative Information',\n  204 : 'No Content',\n  205 : 'Reset Content',\n  206 : 'Partial Content',\n  207 : 'Multi-Status',               // RFC 4918\n  300 : 'Multiple Choices',\n  301 : 'Moved Permanently',\n  302 : 'Moved Temporarily',\n  303 : 'See Other',\n  304 : 'Not Modified',\n  305 : 'Use Proxy',\n  307 : 'Temporary Redirect',\n  400 : 'Bad Request',\n  401 : 'Unauthorized',\n  402 : 'Payment Required',\n  403 : 'Forbidden',\n  404 : 'Not Found',\n  405 : 'Method Not Allowed',\n  406 : 'Not Acceptable',\n  407 : 'Proxy Authentication Required',\n  408 : 'Request Time-out',\n  409 : 'Conflict',\n  410 : 'Gone',\n  411 : 'Length Required',\n  412 : 'Precondition Failed',\n  413 : 'Request Entity Too Large',\n  414 : 'Request-URI Too Large',\n  415 : 'Unsupported Media Type',\n  416 : 'Requested Range Not Satisfiable',\n  417 : 'Expectation Failed',\n  418 : 'I\\'m a teapot',              // RFC 2324\n  422 : 'Unprocessable Entity',       // RFC 4918\n  423 : 'Locked',                     // RFC 4918\n  424 : 'Failed Dependency',          // RFC 4918\n  425 : 'Unordered Collection',       // RFC 4918\n  426 : 'Upgrade Required',           // RFC 2817\n  428 : 'Precondition Required',      // RFC 6585\n  429 : 'Too Many Requests',          // RFC 6585\n  431 : 'Request Header Fields Too Large',// RFC 6585\n  500 : 'Internal Server Error',\n  501 : 'Not Implemented',\n  502 : 'Bad Gateway',\n  503 : 'Service Unavailable',\n  504 : 'Gateway Time-out',\n  505 : 'HTTP Version Not Supported',\n  506 : 'Variant Also Negotiates',    // RFC 2295\n  507 : 'Insufficient Storage',       // RFC 4918\n  509 : 'Bandwidth Limit Exceeded',\n  510 : 'Not Extended',               // RFC 2774\n  511 : 'Network Authentication Required' // RFC 6585\n};\n\n\nvar connectionExpression = /Connection/i;\nvar transferEncodingExpression = /Transfer-Encoding/i;\nvar closeExpression = /close/i;\nvar chunkExpression = /chunk/i;\nvar contentLengthExpression = /Content-Length/i;\nvar dateExpression = /Date/i;\nvar expectExpression = /Expect/i;\nvar continueExpression = /100-continue/i;\n\nvar dateCache;\nfunction utcDate() {\n  if (!dateCache) {\n    var d = new Date();\n    dateCache = d.toUTCString();\n    timers.enroll(utcDate, 1000 - d.getMilliseconds());\n    timers._unrefActive(utcDate);\n  }\n  return dateCache;\n}\nutcDate._onTimeout = function() {\n  dateCache = undefined;\n};\n\n\n/* Abstract base class for ServerRequest and ClientResponse. */\nfunction IncomingMessage(socket) {\n  Stream.Readable.call(this);\n\n  // XXX This implementation is kind of all over the place\n  // When the parser emits body chunks, they go in this list.\n  // _read() pulls them out, and when it finds EOF, it ends.\n\n  this.socket = socket;\n  this.connection = socket;\n\n  this.httpVersion = null;\n  this.complete = false;\n  this.headers = {};\n  this.trailers = {};\n\n  this.readable = true;\n\n  this._pendings = [];\n  this._pendingIndex = 0;\n\n  // request (server) only\n  this.url = '';\n  this.method = null;\n\n  // response (client) only\n  this.statusCode = null;\n  this.client = this.socket;\n\n  // flag for backwards compatibility grossness.\n  this._consuming = false;\n\n  // flag for when we decide that this message cannot possibly be\n  // read by the user, so there's no point continuing to handle it.\n  this._dumped = false;\n}\nutil.inherits(IncomingMessage, Stream.Readable);\n\n\nexports.IncomingMessage = IncomingMessage;\n\n\nIncomingMessage.prototype.setTimeout = function(msecs, callback) {\n  if (callback)\n    this.on('timeout', callback);\n  this.socket.setTimeout(msecs);\n};\n\n\nIncomingMessage.prototype.read = function(n) {\n  this._consuming = true;\n  this.read = Stream.Readable.prototype.read;\n  return this.read(n);\n};\n\n\nIncomingMessage.prototype._read = function(n) {\n  // We actually do almost nothing here, because the parserOnBody\n  // function fills up our internal buffer directly.  However, we\n  // do need to unpause the underlying socket so that it flows.\n  if (!this.socket.readable)\n    this.push(null);\n  else\n    readStart(this.socket);\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nIncomingMessage.prototype.destroy = function(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n};\n\n\n// Add the given (field, value) pair to the message\n//\n// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n// same header with a ', ' if the header in question supports specification of\n// multiple values this way. If not, we declare the first instance the winner\n// and drop the second. Extended header fields (those beginning with 'x-') are\n// always joined.\nIncomingMessage.prototype._addHeaderLine = function(field, value) {\n  var dest = this.complete ? this.trailers : this.headers;\n\n  field = field.toLowerCase();\n  switch (field) {\n    // Array headers:\n    case 'set-cookie':\n      if (dest[field] !== undefined) {\n        dest[field].push(value);\n      } else {\n        dest[field] = [value];\n      }\n      break;\n\n    // Comma separate. Maybe make these arrays?\n    case 'accept':\n    case 'accept-charset':\n    case 'accept-encoding':\n    case 'accept-language':\n    case 'connection':\n    case 'cookie':\n    case 'pragma':\n    case 'link':\n    case 'www-authenticate':\n    case 'proxy-authenticate':\n    case 'sec-websocket-extensions':\n    case 'sec-websocket-protocol':\n      if (dest[field] !== undefined) {\n        dest[field] += ', ' + value;\n      } else {\n        dest[field] = value;\n      }\n      break;\n\n\n    default:\n      if (field.slice(0, 2) == 'x-') {\n        // except for x-\n        if (dest[field] !== undefined) {\n          dest[field] += ', ' + value;\n        } else {\n          dest[field] = value;\n        }\n      } else {\n        // drop duplicates\n        if (dest[field] === undefined) dest[field] = value;\n      }\n      break;\n  }\n};\n\n\n// Call this instead of resume() if we want to just\n// dump all the data to /dev/null\nIncomingMessage.prototype._dump = function() {\n  if (!this._dumped) {\n    this._dumped = true;\n    if (this.socket.parser) this.socket.parser.incoming = null;\n    this.push(null);\n    readStart(this.socket);\n    this.read();\n  }\n};\n\n\nfunction OutgoingMessage() {\n  Stream.call(this);\n\n  this.output = [];\n  this.outputEncodings = [];\n\n  this.writable = true;\n\n  this._last = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n\n  this._headerSent = false;\n  this._header = '';\n  this._hasBody = true;\n  this._trailer = '';\n\n  this.finished = false;\n  this._hangupClose = false;\n\n  this.socket = null;\n  this.connection = null;\n}\nutil.inherits(OutgoingMessage, Stream);\n\n\nexports.OutgoingMessage = OutgoingMessage;\n\n\nOutgoingMessage.prototype.setTimeout = function(msecs, callback) {\n  if (callback)\n    this.on('timeout', callback);\n  if (!this.socket) {\n    this.once('socket', function(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else\n    this.socket.setTimeout(msecs);\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nOutgoingMessage.prototype.destroy = function(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n  else\n    this.once('socket', function(socket) {\n      socket.destroy(error);\n    });\n};\n\n\n// This abstract either writing directly to the socket or buffering it.\nOutgoingMessage.prototype._send = function(data, encoding) {\n  // This is a shameful hack to get the headers and first body chunk onto\n  // the same packet. Future versions of Node are going to take care of\n  // this at a lower level and in a more general way.\n  if (!this._headerSent) {\n    if (typeof data === 'string' &&\n        encoding !== 'hex' &&\n        encoding !== 'base64') {\n      data = this._header + data;\n    } else {\n      this.output.unshift(this._header);\n      this.outputEncodings.unshift('ascii');\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data, encoding);\n};\n\n\nOutgoingMessage.prototype._writeRaw = function(data, encoding) {\n  if (data.length === 0) {\n    return true;\n  }\n\n  if (this.connection &&\n      this.connection._httpMessage === this &&\n      this.connection.writable &&\n      !this.connection.destroyed) {\n    // There might be pending data in the this.output buffer.\n    while (this.output.length) {\n      if (!this.connection.writable) {\n        this._buffer(data, encoding);\n        return false;\n      }\n      var c = this.output.shift();\n      var e = this.outputEncodings.shift();\n      this.connection.write(c, e);\n    }\n\n    // Directly write to socket.\n    return this.connection.write(data, encoding);\n  } else if (this.connection && this.connection.destroyed) {\n    // The socket was destroyed.  If we're still trying to write to it,\n    // then we haven't gotten the 'close' event yet.\n    return false;\n  } else {\n    // buffer, as long as we're not destroyed.\n    this._buffer(data, encoding);\n    return false;\n  }\n};\n\n\nOutgoingMessage.prototype._buffer = function(data, encoding) {\n  this.output.push(data);\n  this.outputEncodings.push(encoding);\n\n  return false;\n};\n\n\nOutgoingMessage.prototype._storeHeader = function(firstLine, headers) {\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\r\\n'\n  // in the case of response it is: 'HTTP/1.1 200 OK\\r\\n'\n  var state = {\n    sentConnectionHeader: false,\n    sentContentLengthHeader: false,\n    sentTransferEncodingHeader: false,\n    sentDateHeader: false,\n    sentExpect: false,\n    messageHeader: firstLine\n  };\n\n  var field, value;\n  var self = this;\n\n  if (headers) {\n    var keys = Object.keys(headers);\n    var isArray = (Array.isArray(headers));\n    var field, value;\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      if (isArray) {\n        field = headers[key][0];\n        value = headers[key][1];\n      } else {\n        field = key;\n        value = headers[key];\n      }\n\n      if (Array.isArray(value)) {\n        for (var j = 0; j < value.length; j++) {\n          storeHeader(this, state, field, value[j]);\n        }\n      } else {\n        storeHeader(this, state, field, value);\n      }\n    }\n  }\n\n  // Date header\n  if (this.sendDate == true && state.sentDateHeader == false) {\n    state.messageHeader += 'Date: ' + utcDate() + CRLF;\n  }\n\n  // Force the connection to close when the response is a 204 No Content or\n  // a 304 Not Modified and the user has set a \"Transfer-Encoding: chunked\"\n  // header.\n  //\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\n  // node.js used to send out a zero chunk anyway to accommodate clients\n  // that don't have special handling for those responses.\n  //\n  // It was pointed out that this might confuse reverse proxies to the point\n  // of creating security liabilities, so suppress the zero chunk and force\n  // the connection to close.\n  var statusCode = this.statusCode;\n  if ((statusCode == 204 || statusCode === 304) &&\n      this.chunkedEncoding === true) {\n    debug(statusCode + ' response should not use chunked encoding,' +\n          ' closing connection.');\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n\n  // keep-alive logic\n  if (state.sentConnectionHeader === false) {\n    var shouldSendKeepAlive = this.shouldKeepAlive &&\n        (state.sentContentLengthHeader ||\n         this.useChunkedEncodingByDefault ||\n         this.agent);\n    if (shouldSendKeepAlive) {\n      state.messageHeader += 'Connection: keep-alive\\r\\n';\n    } else {\n      this._last = true;\n      state.messageHeader += 'Connection: close\\r\\n';\n    }\n  }\n\n  if (state.sentContentLengthHeader == false &&\n      state.sentTransferEncodingHeader == false) {\n    if (this._hasBody) {\n      if (this.useChunkedEncodingByDefault) {\n        state.messageHeader += 'Transfer-Encoding: chunked\\r\\n';\n        this.chunkedEncoding = true;\n      } else {\n        this._last = true;\n      }\n    } else {\n      // Make sure we don't end the 0\\r\\n\\r\\n at the end of the message.\n      this.chunkedEncoding = false;\n    }\n  }\n\n  this._header = state.messageHeader + CRLF;\n  this._headerSent = false;\n\n  // wait until the first body chunk, or close(), is sent to flush,\n  // UNLESS we're sending Expect: 100-continue.\n  if (state.sentExpect) this._send('');\n};\n\nfunction storeHeader(self, state, field, value) {\n  // Protect against response splitting. The if statement is there to\n  // minimize the performance impact in the common case.\n  if (/[\\r\\n]/.test(value))\n    value = value.replace(/[\\r\\n]+[ \\t]*/g, '');\n\n  state.messageHeader += field + ': ' + value + CRLF;\n\n  if (connectionExpression.test(field)) {\n    state.sentConnectionHeader = true;\n    if (closeExpression.test(value)) {\n      self._last = true;\n    } else {\n      self.shouldKeepAlive = true;\n    }\n\n  } else if (transferEncodingExpression.test(field)) {\n    state.sentTransferEncodingHeader = true;\n    if (chunkExpression.test(value)) self.chunkedEncoding = true;\n\n  } else if (contentLengthExpression.test(field)) {\n    state.sentContentLengthHeader = true;\n  } else if (dateExpression.test(field)) {\n    state.sentDateHeader = true;\n  } else if (expectExpression.test(field)) {\n    state.sentExpect = true;\n  }\n}\n\n\nOutgoingMessage.prototype.setHeader = function(name, value) {\n  if (arguments.length < 2) {\n    throw new Error('`name` and `value` are required for setHeader().');\n  }\n\n  if (this._header) {\n    throw new Error('Can\\'t set headers after they are sent.');\n  }\n\n  var key = name.toLowerCase();\n  this._headers = this._headers || {};\n  this._headerNames = this._headerNames || {};\n  this._headers[key] = value;\n  this._headerNames[key] = name;\n};\n\n\nOutgoingMessage.prototype.getHeader = function(name) {\n  if (arguments.length < 1) {\n    throw new Error('`name` is required for getHeader().');\n  }\n\n  if (!this._headers) return;\n\n  var key = name.toLowerCase();\n  return this._headers[key];\n};\n\n\nOutgoingMessage.prototype.removeHeader = function(name) {\n  if (arguments.length < 1) {\n    throw new Error('`name` is required for removeHeader().');\n  }\n\n  if (this._header) {\n    throw new Error('Can\\'t remove headers after they are sent.');\n  }\n\n  if (!this._headers) return;\n\n  var key = name.toLowerCase();\n  delete this._headers[key];\n  delete this._headerNames[key];\n};\n\n\nOutgoingMessage.prototype._renderHeaders = function() {\n  if (this._header) {\n    throw new Error('Can\\'t render headers after they are sent to the client.');\n  }\n\n  if (!this._headers) return {};\n\n  var headers = {};\n  var keys = Object.keys(this._headers);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    headers[this._headerNames[key]] = this._headers[key];\n  }\n  return headers;\n};\n\n\nObject.defineProperty(OutgoingMessage.prototype, 'headersSent', {\n  configurable: true,\n  enumerable: true,\n  get: function() { return !!this._header; }\n});\n\n\n// Convert a number in the range 0-15 to a lowercase hexadecimal digit.\nfunction hex(val) {\n  // The comparison and bit hacks are deliberate. We could look up the\n  // value in a buffer with hexdigits[val & 15] but that adds a couple\n  // of bounds checks to each conversion.\n  return val <= 9 ? (val | 48) : ((val - 9) | 96);\n}\n\n\nfunction chunkify(chunk, headers, trailers, last) {\n  var chunklen = chunk.length;\n  var buflen = chunklen + 4;  // '\\r\\n' + chunk + '\\r\\n'\n  var offset = 0;\n  var octets = 1;\n\n  // Skip expensive Buffer.byteLength() calls; only ISO-8859-1 characters\n  // are allowed in HTTP headers, therefore:\n  //\n  //   headers.length == Buffer.byteLength(headers.length)\n  //   trailers.length == Buffer.byteLength(trailers.length)\n  //\n  // Note: the actual encoding that is used is ASCII. That's de jure\n  // a violation of the spec but de facto correct because many HTTP\n  // clients get confused by non-ASCII headers.\n  if (last === true) buflen += 5;  // '0\\r\\n\\r\\n'\n  if (headers !== '') buflen += headers.length;\n  if (trailers !== '') buflen += trailers.length;\n\n  if (chunklen & 0xf0000000) octets += 7;\n  else if (chunklen & 0xf000000) octets += 6;\n  else if (chunklen & 0xf00000) octets += 5;\n  else if (chunklen & 0xf0000) octets += 4;\n  else if (chunklen & 0xf000) octets += 3;\n  else if (chunklen & 0xf00) octets += 2;\n  else if (chunklen & 0xf0) octets += 1;\n  buflen += octets;\n\n  var buf = new Buffer(buflen);\n\n  if (headers !== '') {\n    buf.write(headers, 0, headers.length, 'ascii');\n    offset = headers.length;\n  }\n\n  // Write chunk length in hex to buffer. This effectively limits us\n  // to 4 GB chunks but that's okay because buffers are max 1 GB anyway.\n  switch (octets) {\n    case 8: buf[offset++] = hex((chunklen >>> 28) & 15);\n    case 7: buf[offset++] = hex((chunklen >>> 24) & 15);\n    case 6: buf[offset++] = hex((chunklen >>> 20) & 15);\n    case 5: buf[offset++] = hex((chunklen >>> 16) & 15);\n    case 4: buf[offset++] = hex((chunklen >>> 12) & 15);\n    case 3: buf[offset++] = hex((chunklen >>> 8) & 15);\n    case 2: buf[offset++] = hex((chunklen >>> 4) & 15);\n  }\n  buf[offset++] = hex(chunklen & 15);\n\n  // Add '\\r\\n'.\n  buf[offset++] = 13;\n  buf[offset++] = 10;\n\n  // Copy buffer.\n  chunk.copy(buf, offset);\n  offset += chunklen;\n\n  // Add trailing '\\r\\n'.\n  buf[offset++] = 13;\n  buf[offset++] = 10;\n\n  if (last === true) {\n    // Add trailing '0\\r\\n\\r\\n'.\n    buf[offset++] = 48;\n    buf[offset++] = 13;\n    buf[offset++] = 10;\n    buf[offset++] = 13;\n    buf[offset++] = 10;\n  }\n\n  if (trailers !== '') {\n    buf.write(trailers, offset, trailers.length, 'ascii');\n  }\n\n  return buf;\n}\n\n\nOutgoingMessage.prototype.write = function(chunk, encoding) {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  if (!this._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring write() calls.');\n    return true;\n  }\n\n  if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {\n    throw new TypeError('first argument must be a string or Buffer');\n  }\n\n  // If we get an empty string or buffer, then just do nothing, and\n  // signal the user to keep writing.\n  if (chunk.length === 0) return true;\n\n  var len, ret;\n  if (this.chunkedEncoding) {\n    if (typeof(chunk) === 'string' &&\n        encoding !== 'hex' &&\n        encoding !== 'base64') {\n      len = Buffer.byteLength(chunk, encoding);\n      chunk = len.toString(16) + CRLF + chunk + CRLF;\n      ret = this._send(chunk, encoding);\n    } else if (Buffer.isBuffer(chunk)) {\n      var buf = chunkify(chunk, '', '', false);\n      ret = this._send(buf, encoding);\n    } else {\n      // Non-toString-friendly encoding.\n      if (typeof chunk === 'string')\n        len = Buffer.byteLength(chunk, encoding);\n      else\n        len = chunk.length;\n\n      this._send(len.toString(16) + CRLF, 'ascii');\n      this._send(chunk, encoding);\n      ret = this._send(CRLF);\n    }\n  } else {\n    ret = this._send(chunk, encoding);\n  }\n\n  debug('write ret = ' + ret);\n  return ret;\n};\n\n\nOutgoingMessage.prototype.addTrailers = function(headers) {\n  this._trailer = '';\n  var keys = Object.keys(headers);\n  var isArray = (Array.isArray(headers));\n  var field, value;\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n\n    this._trailer += field + ': ' + value + CRLF;\n  }\n};\n\n\nvar zero_chunk_buf = new Buffer('\\r\\n0\\r\\n');\nvar crlf_buf = new Buffer('\\r\\n');\n\n\nOutgoingMessage.prototype.end = function(data, encoding) {\n  if (this.finished) {\n    return false;\n  }\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  if (data && !this._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring data passed to end().');\n    data = false;\n  }\n\n  var ret;\n\n  var hot = this._headerSent === false &&\n            (data && data.length > 0) &&\n            this.output.length === 0 &&\n            this.connection &&\n            this.connection.writable &&\n            this.connection._httpMessage === this;\n\n  // The benefits of the hot-path optimization below start to fall\n  // off when the buffer size gets up near 128KB, because the cost\n  // of the copy is more than the cost of the extra write() call.\n  // Switch to the write/end method at that point.  Heuristics and\n  // magic numbers are awful, but slow http responses are worse.\n  if (hot && Buffer.isBuffer(data) && data.length > 120 * 1024)\n    hot = false;\n\n  // Can't concatenate safely with hex or base64 encodings.\n  if (encoding === 'hex' || encoding === 'base64')\n    hot = false;\n\n  if (hot) {\n    // Hot path. They're doing\n    //   res.writeHead();\n    //   res.end(blah);\n    // HACKY.\n\n    if (typeof data === 'string') {\n      if (this.chunkedEncoding) {\n        var l = Buffer.byteLength(data, encoding).toString(16);\n        ret = this.connection.write(this._header + l + CRLF +\n                                    data + '\\r\\n0\\r\\n' +\n                                    this._trailer + '\\r\\n', encoding);\n      } else {\n        ret = this.connection.write(this._header + data, encoding);\n      }\n    } else if (Buffer.isBuffer(data)) {\n      if (this.chunkedEncoding) {\n        var buf = chunkify(data, this._header, this._trailer, true);\n        ret = this.connection.write(buf);\n      } else {\n        var header_len = this._header.length;\n        var buf = new Buffer(header_len + data.length);\n        buf.write(this._header, 0, header_len, 'ascii');\n        data.copy(buf, header_len);\n        ret = this.connection.write(buf);\n      }\n    } else {\n      throw new TypeError('first argument must be a string or Buffer');\n    }\n    this._headerSent = true;\n\n  } else if (data) {\n    // Normal body write.\n    ret = this.write(data, encoding);\n  }\n\n  if (!hot) {\n    if (this.chunkedEncoding) {\n      ret = this._send('0\\r\\n' + this._trailer + '\\r\\n', 'ascii');\n    } else {\n      // Force a flush, HACK.\n      ret = this._send('');\n    }\n  }\n\n  this.finished = true;\n\n  // There is the first message on the outgoing queue, and we've sent\n  // everything to the socket.\n  debug('outgoing message end.');\n  if (this.output.length === 0 && this.connection._httpMessage === this) {\n    this._finish();\n  }\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype._finish = function() {\n  assert(this.connection);\n  if (this instanceof ServerResponse) {\n    ;\n    ;\n  } else {\n    assert(this instanceof ClientRequest);\n    ;\n    ;\n  }\n  this.emit('finish');\n};\n\n\nOutgoingMessage.prototype._flush = function() {\n  // This logic is probably a bit confusing. Let me explain a bit:\n  //\n  // In both HTTP servers and clients it is possible to queue up several\n  // outgoing messages. This is easiest to imagine in the case of a client.\n  // Take the following situation:\n  //\n  //    req1 = client.request('GET', '/');\n  //    req2 = client.request('POST', '/');\n  //\n  // When the user does\n  //\n  //   req2.write('hello world\\n');\n  //\n  // it's possible that the first request has not been completely flushed to\n  // the socket yet. Thus the outgoing messages need to be prepared to queue\n  // up data internally before sending it on further to the socket's queue.\n  //\n  // This function, outgoingFlush(), is called by both the Server and Client\n  // to attempt to flush any pending messages out to the socket.\n\n  if (!this.socket) return;\n\n  var ret;\n  while (this.output.length) {\n\n    if (!this.socket.writable) return; // XXX Necessary?\n\n    var data = this.output.shift();\n    var encoding = this.outputEncodings.shift();\n\n    ret = this.socket.write(data, encoding);\n  }\n\n  if (this.finished) {\n    // This is a queue to the server or client to bring in the next this.\n    this._finish();\n  } else if (ret) {\n    // This is necessary to prevent https from breaking\n    this.emit('drain');\n  }\n};\n\n\n\n\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n\n  if (req.method === 'HEAD') this._hasBody = false;\n\n  this.sendDate = true;\n\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);\n    this.shouldKeepAlive = false;\n  }\n}\nutil.inherits(ServerResponse, OutgoingMessage);\n\n\nexports.ServerResponse = ServerResponse;\n\nServerResponse.prototype.statusCode = 200;\n\nfunction onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var obj = new events.EventEmitter;\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}\n\nServerResponse.prototype.assignSocket = function(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on('close', onServerResponseClose);\n  this.socket = socket;\n  this.connection = socket;\n  this.emit('socket', socket);\n  this._flush();\n};\n\nServerResponse.prototype.detachSocket = function(socket) {\n  assert(socket._httpMessage == this);\n  socket.removeListener('close', onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = this.connection = null;\n};\n\nServerResponse.prototype.writeContinue = function() {\n  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii');\n  this._sent100 = true;\n};\n\nServerResponse.prototype._implicitHeader = function() {\n  this.writeHead(this.statusCode);\n};\n\nServerResponse.prototype.writeHead = function(statusCode) {\n  var reasonPhrase, headers, headerIndex;\n\n  if (typeof arguments[1] == 'string') {\n    reasonPhrase = arguments[1];\n    headerIndex = 2;\n  } else {\n    reasonPhrase = STATUS_CODES[statusCode] || 'unknown';\n    headerIndex = 1;\n  }\n  this.statusCode = statusCode;\n\n  var obj = arguments[headerIndex];\n\n  if (obj && this._headers) {\n    // Slow-case: when progressive API and header fields are passed.\n    headers = this._renderHeaders();\n\n    if (Array.isArray(obj)) {\n      // handle array case\n      // TODO: remove when array is no longer accepted\n      var field;\n      for (var i = 0, len = obj.length; i < len; ++i) {\n        field = obj[i][0];\n        if (headers[field] !== undefined) {\n          obj.push([field, headers[field]]);\n        }\n      }\n      headers = obj;\n\n    } else {\n      // handle object case\n      var keys = Object.keys(obj);\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        if (k) headers[k] = obj[k];\n      }\n    }\n  } else if (this._headers) {\n    // only progressive api is used\n    headers = this._renderHeaders();\n  } else {\n    // only writeHead() called\n    headers = obj;\n  }\n\n  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +\n                   reasonPhrase + CRLF;\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (100 <= statusCode && statusCode <= 199)) {\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response,\n    // consisting only of the Status-Line and optional headers, and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  this._storeHeader(statusLine, headers);\n};\n\nServerResponse.prototype.writeHeader = function() {\n  this.writeHead.apply(this, arguments);\n};\n\n\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly, this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nfunction Agent(options) {\n  EventEmitter.call(this);\n\n  var self = this;\n  self.options = options || {};\n  self.requests = {};\n  self.sockets = {};\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\n  self.on('free', function(socket, host, port, localAddress) {\n    var name = host + ':' + port;\n    if (localAddress) {\n      name += ':' + localAddress;\n    }\n\n    if (!socket.destroyed &&\n        self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n      if (self.requests[name].length === 0) {\n        // don't leak\n        delete self.requests[name];\n      }\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy();\n    }\n  });\n  self.createConnection = net.createConnection;\n}\nutil.inherits(Agent, EventEmitter);\nexports.Agent = Agent;\n\nAgent.defaultMaxSockets = 5;\n\nAgent.prototype.defaultPort = 80;\nAgent.prototype.addRequest = function(req, host, port, localAddress) {\n  var name = host + ':' + port;\n  if (localAddress) {\n    name += ':' + localAddress;\n  }\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n  if (this.sockets[name].length < this.maxSockets) {\n    // If we are under maxSockets create a new one.\n    req.onSocket(this.createSocket(name, host, port, localAddress, req));\n  } else {\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n    this.requests[name].push(req);\n  }\n};\nAgent.prototype.createSocket = function(name, host, port, localAddress, req) {\n  var self = this;\n  var options = util._extend({}, self.options);\n  options.port = port;\n  options.host = host;\n  options.localAddress = localAddress;\n\n  options.servername = host;\n  if (req) {\n    var hostHeader = req.getHeader('host');\n    if (hostHeader) {\n      options.servername = hostHeader.replace(/:.*$/, '');\n    }\n  }\n\n  var s = self.createConnection(options);\n  if (!self.sockets[name]) {\n    self.sockets[name] = [];\n  }\n  this.sockets[name].push(s);\n  var onFree = function() {\n    self.emit('free', s, host, port, localAddress);\n  }\n  s.on('free', onFree);\n  var onClose = function(err) {\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool, just close it.\n    // All socket errors end in a close event anyway.\n    self.removeSocket(s, name, host, port, localAddress);\n  }\n  s.on('close', onClose);\n  var onRemove = function() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the pool\n    //  because it'll be locked up indefinitely\n    self.removeSocket(s, name, host, port, localAddress);\n    s.removeListener('close', onClose);\n    s.removeListener('free', onFree);\n    s.removeListener('agentRemove', onRemove);\n  }\n  s.on('agentRemove', onRemove);\n  return s;\n};\nAgent.prototype.removeSocket = function(s, name, host, port, localAddress) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s);\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1);\n      if (this.sockets[name].length === 0) {\n        // don't leak\n        delete this.sockets[name];\n      }\n    }\n  }\n  if (this.requests[name] && this.requests[name].length) {\n    var req = this.requests[name][0];\n    // If we have pending requests and a socket gets closed a new one\n    this.createSocket(name, host, port, localAddress, req).emit('free');\n  }\n};\n\nvar globalAgent = new Agent();\nexports.globalAgent = globalAgent;\n\n\nfunction ClientRequest(options, cb) {\n  var self = this;\n  OutgoingMessage.call(self);\n\n  self.agent = options.agent === undefined ? globalAgent : options.agent;\n\n  var defaultPort = options.defaultPort || 80;\n\n  var port = options.port || defaultPort;\n  var host = options.hostname || options.host || 'localhost';\n\n  if (options.setHost === undefined) {\n    var setHost = true;\n  }\n\n  self.socketPath = options.socketPath;\n\n  var method = self.method = (options.method || 'GET').toUpperCase();\n  self.path = options.path || '/';\n  if (cb) {\n    self.once('response', cb);\n  }\n\n  if (!Array.isArray(options.headers)) {\n    if (options.headers) {\n      var keys = Object.keys(options.headers);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var key = keys[i];\n        self.setHeader(key, options.headers[key]);\n      }\n    }\n    if (host && !this.getHeader('host') && setHost) {\n      var hostHeader = host;\n      if (port && +port !== defaultPort) {\n        hostHeader += ':' + port;\n      }\n      this.setHeader('Host', hostHeader);\n    }\n  }\n\n  if (options.auth && !this.getHeader('Authorization')) {\n    //basic auth\n    this.setHeader('Authorization', 'Basic ' +\n                   new Buffer(options.auth).toString('base64'));\n  }\n\n  if (method === 'GET' || method === 'HEAD' || method === 'CONNECT') {\n    self.useChunkedEncodingByDefault = false;\n  } else {\n    self.useChunkedEncodingByDefault = true;\n  }\n\n  if (Array.isArray(options.headers)) {\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\r\\n',\n                      options.headers);\n  } else if (self.getHeader('expect')) {\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\r\\n',\n                      self._renderHeaders());\n  }\n  if (self.socketPath) {\n    self._last = true;\n    self.shouldKeepAlive = false;\n    if (options.createConnection) {\n      self.onSocket(options.createConnection(self.socketPath));\n    } else {\n      self.onSocket(net.createConnection(self.socketPath));\n    }\n  } else if (self.agent) {\n    // If there is an agent we should default to Connection:keep-alive.\n    self._last = false;\n    self.shouldKeepAlive = true;\n    self.agent.addRequest(self, host, port, options.localAddress);\n  } else {\n    // No agent, default to Connection:close.\n    self._last = true;\n    self.shouldKeepAlive = false;\n    if (options.createConnection) {\n      options.port = port;\n      options.host = host;\n      var conn = options.createConnection(options);\n    } else {\n      var conn = net.createConnection({\n        port: port,\n        host: host,\n        localAddress: options.localAddress\n      });\n    }\n    self.onSocket(conn);\n  }\n\n  self._deferToConnect(null, null, function() {\n    self._flush();\n    self = null;\n  });\n\n}\nutil.inherits(ClientRequest, OutgoingMessage);\n\nexports.ClientRequest = ClientRequest;\n\nClientRequest.prototype._implicitHeader = function() {\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n',\n                    this._renderHeaders());\n};\n\nClientRequest.prototype.abort = function() {\n  // If we're aborting, we don't care about any more response data.\n  if (this.res)\n    this.res._dump();\n  else\n    this.once('response', function(res) {\n      res._dump();\n    });\n\n  if (this.socket) {\n    // in-progress\n    this.socket.destroy();\n  } else {\n    // haven't been assigned a socket yet.\n    // this could be more efficient, it could\n    // remove itself from the pending requests\n    this._deferToConnect('destroy', []);\n  }\n};\n\n\nfunction createHangUpError() {\n  var error = new Error('socket hang up');\n  error.code = 'ECONNRESET';\n  return error;\n}\n\n// Free the parser and also break any links that it\n// might have to any other things.\n// TODO: All parser data should be attached to a\n// single object, so that it can be easily cleaned\n// up by doing `parser.data = {}`, which should\n// be done in FreeList.free.  `parsers.free(parser)`\n// should be all that is needed.\nfunction freeParser(parser, req) {\n  if (parser) {\n    parser._headers = [];\n    parser.onIncoming = null;\n    if (parser.socket) {\n      parser.socket.onend = null;\n      parser.socket.ondata = null;\n      parser.socket.parser = null;\n    }\n    parser.socket = null;\n    parser.incoming = null;\n    parsers.free(parser);\n    parser = null;\n  }\n  if (req) {\n    req.parser = null;\n  }\n}\n\n\nfunction socketCloseListener() {\n  var socket = this;\n  var parser = socket.parser;\n  var req = socket._httpMessage;\n  debug('HTTP socket close');\n  req.emit('close');\n  if (req.res && req.res.readable) {\n    // Socket closed before we emitted 'end' below.\n    req.res.emit('aborted');\n    var res = req.res;\n    res.on('end', function() {\n      res.emit('close');\n    });\n    res.push(null);\n  } else if (!req.res && !req._hadError) {\n    // This socket error fired before we started to\n    // receive a response. The error needs to\n    // fire on the request.\n    req.emit('error', createHangUpError());\n    req._hadError = true;\n  }\n\n  // Too bad.  That output wasn't getting written.\n  // This is pretty terrible that it doesn't raise an error.\n  // Fixed better in v0.10\n  if (req.output)\n    req.output.length = 0;\n  if (req.outputEncodings)\n    req.outputEncodings.length = 0;\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n}\n\nfunction socketErrorListener(err) {\n  var socket = this;\n  var parser = socket.parser;\n  var req = socket._httpMessage;\n  debug('HTTP SOCKET ERROR: ' + err.message + '\\n' + err.stack);\n\n  if (req) {\n    req.emit('error', err);\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req._hadError = true;\n  }\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n  socket.destroy();\n}\n\nfunction socketOnEnd() {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  if (!req.res) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.emit('error', createHangUpError());\n    req._hadError = true;\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n  socket.destroy();\n}\n\nfunction socketOnData(d, start, end) {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  var ret = parser.execute(d, start, end - start);\n  if (ret instanceof Error) {\n    debug('parse error');\n    freeParser(parser, req);\n    socket.destroy();\n    req.emit('error', ret);\n    req._hadError = true;\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    var bytesParsed = ret;\n    var res = parser.incoming;\n    req.res = res;\n\n    socket.ondata = null;\n    socket.onend = null;\n    parser.finish();\n\n    // This is start + byteParsed\n    var bodyHead = d.slice(start + bytesParsed, end);\n\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (EventEmitter.listenerCount(req, eventName) > 0) {\n      req.upgradeOrConnect = true;\n\n      // detach the socket\n      socket.emit('agentRemove');\n      socket.removeListener('close', socketCloseListener);\n      socket.removeListener('error', socketErrorListener);\n\n      req.emit(eventName, res, socket, bodyHead);\n      req.emit('close');\n    } else {\n      // Got Upgrade header or CONNECT method, but have no handler.\n      socket.destroy();\n    }\n    freeParser(parser, req);\n  } else if (parser.incoming && parser.incoming.complete &&\n             // When the status code is 100 (Continue), the server will\n             // send a final response after this client sends a request\n             // body. So, we must not free the parser.\n             parser.incoming.statusCode !== 100) {\n    freeParser(parser, req);\n  }\n}\n\n\n// client\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\n  var parser = this;\n  var socket = this.socket;\n  var req = socket._httpMessage;\n\n\n  // propogate \"domain\" setting...\n  if (req.domain && !res.domain) {\n    debug('setting \"res.domain\"');\n    res.domain = req.domain;\n  }\n\n  debug('AGENT incoming response!');\n\n  if (req.res) {\n    // We already have a response object, this means the server\n    // sent a double response.\n    socket.destroy();\n    return;\n  }\n  req.res = res;\n\n  // Responses to CONNECT request is handled as Upgrade.\n  if (req.method === 'CONNECT') {\n    res.upgrade = true;\n    return true; // skip body\n  }\n\n  // Responses to HEAD requests are crazy.\n  // HEAD responses aren't allowed to have an entity-body\n  // but *can* have a content-length which actually corresponds\n  // to the content-length of the entity-body had the request\n  // been a GET.\n  var isHeadResponse = req.method == 'HEAD';\n  debug('AGENT isHeadResponse ' + isHeadResponse);\n\n  if (res.statusCode == 100) {\n    // restart the parser, as this is a continue message.\n    delete req.res; // Clear res so that we don't hit double-responses.\n    req.emit('continue');\n    return true;\n  }\n\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    // Server MUST respond with Connection:keep-alive for us to enable it.\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\n    // keep the connection open.\n    req.shouldKeepAlive = false;\n  }\n\n\n  ;\n  ;\n  req.res = res;\n  res.req = req;\n\n  // add our listener first, so that we guarantee socket cleanup\n  res.on('end', responseOnEnd);\n  var handled = req.emit('response', res);\n\n  // If the user did not listen for the 'response' event, then they\n  // can't possibly read the data, so we ._dump() it into the void\n  // so that the socket doesn't hang there in a paused state.\n  if (!handled)\n    res._dump();\n\n  return isHeadResponse;\n}\n\n// client\nfunction responseOnEnd() {\n  var res = this;\n  var req = res.req;\n  var socket = req.socket;\n\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug('AGENT socket.destroySoon()');\n      socket.destroySoon();\n    }\n    assert(!socket.writable);\n  } else {\n    debug('AGENT socket keep-alive');\n    if (req.timeoutCb) {\n      socket.setTimeout(0, req.timeoutCb);\n      req.timeoutCb = null;\n    }\n    socket.removeListener('close', socketCloseListener);\n    socket.removeListener('error', socketErrorListener);\n    // Mark this socket as available, AFTER user-added end\n    // handlers have a chance to run.\n    process.nextTick(function() {\n      socket.emit('free');\n    });\n  }\n}\n\nClientRequest.prototype.onSocket = function(socket) {\n  var req = this;\n\n  process.nextTick(function() {\n    var parser = parsers.alloc();\n    req.socket = socket;\n    req.connection = socket;\n    parser.reinitialize(HTTPParser.RESPONSE);\n    parser.socket = socket;\n    parser.incoming = null;\n    req.parser = parser;\n\n    socket.parser = parser;\n    socket._httpMessage = req;\n\n    // Setup \"drain\" propogation.\n    httpSocketSetup(socket);\n\n    // Propagate headers limit from request object to parser\n    if (typeof req.maxHeadersCount === 'number') {\n      parser.maxHeaderPairs = req.maxHeadersCount << 1;\n    } else {\n      // Set default value because parser may be reused from FreeList\n      parser.maxHeaderPairs = 2000;\n    }\n\n    socket.on('error', socketErrorListener);\n    socket.ondata = socketOnData;\n    socket.onend = socketOnEnd;\n    socket.on('close', socketCloseListener);\n    parser.onIncoming = parserOnIncomingClient;\n    req.emit('socket', socket);\n  });\n\n};\n\nClientRequest.prototype._deferToConnect = function(method, arguments_, cb) {\n  // This function is for calls that need to happen once the socket is\n  // connected and writable. It's an important promisy thing for all the socket\n  // calls that happen either now (when a socket is assigned) or\n  // in the future (when a socket gets assigned out of the pool and is\n  // eventually writable).\n  var self = this;\n  var onSocket = function() {\n    if (self.socket.writable) {\n      if (method) {\n        self.socket[method].apply(self.socket, arguments_);\n      }\n      if (cb) { cb(); }\n    } else {\n      self.socket.once('connect', function() {\n        if (method) {\n          self.socket[method].apply(self.socket, arguments_);\n        }\n        if (cb) { cb(); }\n      });\n    }\n  }\n  if (!self.socket) {\n    self.once('socket', onSocket);\n  } else {\n    onSocket();\n  }\n};\n\nClientRequest.prototype.setTimeout = function(msecs, callback) {\n  if (callback) this.once('timeout', callback);\n\n  var self = this;\n  function emitTimeout() {\n    self.emit('timeout');\n  }\n\n  if (this.socket && this.socket.writable) {\n    if (this.timeoutCb)\n      this.socket.setTimeout(0, this.timeoutCb);\n    this.timeoutCb = emitTimeout;\n    this.socket.setTimeout(msecs, emitTimeout);\n    return;\n  }\n\n  // Set timeoutCb so that it'll get cleaned up on request end\n  this.timeoutCb = emitTimeout;\n  if (this.socket) {\n    var sock = this.socket;\n    this.socket.once('connect', function() {\n      sock.setTimeout(msecs, emitTimeout);\n    });\n    return;\n  }\n\n  this.once('socket', function(sock) {\n    sock.setTimeout(msecs, emitTimeout);\n  });\n};\n\nClientRequest.prototype.setNoDelay = function() {\n  this._deferToConnect('setNoDelay', arguments);\n};\nClientRequest.prototype.setSocketKeepAlive = function() {\n  this._deferToConnect('setKeepAlive', arguments);\n};\n\nClientRequest.prototype.clearTimeout = function(cb) {\n  this.setTimeout(0, cb);\n};\n\nexports.request = function(options, cb) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  }\n\n  if (options.protocol && options.protocol !== 'http:') {\n    throw new Error('Protocol:' + options.protocol + ' not supported.');\n  }\n\n  return new ClientRequest(options, cb);\n};\n\nexports.get = function(options, cb) {\n  var req = exports.request(options, cb);\n  req.end();\n  return req;\n};\n\n\nfunction ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n}\n\n\nfunction httpSocketSetup(socket) {\n  socket.removeListener('drain', ondrain);\n  socket.on('drain', ondrain);\n}\n\n\nfunction Server(requestListener) {\n  if (!(this instanceof Server)) return new Server(requestListener);\n  net.Server.call(this, { allowHalfOpen: true });\n\n  if (requestListener) {\n    this.addListener('request', requestListener);\n  }\n\n  // Similar option to this. Too lazy to write my own docs.\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n  this.httpAllowHalfOpen = false;\n\n  this.addListener('connection', connectionListener);\n\n  this.addListener('clientError', function(err, conn) {\n    conn.destroy(err);\n  });\n\n  this.timeout = 2 * 60 * 1000;\n}\nutil.inherits(Server, net.Server);\n\n\nServer.prototype.setTimeout = function(msecs, callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on('timeout', callback);\n};\n\n\nexports.Server = Server;\n\n\nexports.createServer = function(requestListener) {\n  return new Server(requestListener);\n};\n\n\nfunction connectionListener(socket) {\n  var self = this;\n  var outgoing = [];\n  var incoming = [];\n\n  function abortIncoming() {\n    while (incoming.length) {\n      var req = incoming.shift();\n      req.emit('aborted');\n      req.emit('close');\n    }\n    // abort socket._httpMessage ?\n  }\n\n  function serverSocketCloseListener() {\n    debug('server socket close');\n    // mark this parser as reusable\n    if (this.parser)\n      freeParser(this.parser);\n\n    abortIncoming();\n  }\n\n  debug('SERVER new http connection');\n\n  httpSocketSetup(socket);\n\n  // If the user has added a listener to the server,\n  // request, or response, then it's their responsibility.\n  // otherwise, destroy on timeout by default\n  if (self.timeout)\n    socket.setTimeout(self.timeout);\n  socket.on('timeout', function() {\n    var req = socket.parser && socket.parser.incoming;\n    var reqTimeout = req && !req.complete && req.emit('timeout', socket);\n    var res = socket._httpMessage;\n    var resTimeout = res && res.emit('timeout', socket);\n    var serverTimeout = self.emit('timeout', socket);\n\n    if (!reqTimeout && !resTimeout && !serverTimeout)\n      socket.destroy();\n  });\n\n  var parser = parsers.alloc();\n  parser.reinitialize(HTTPParser.REQUEST);\n  parser.socket = socket;\n  socket.parser = parser;\n  parser.incoming = null;\n\n  // Propagate headers limit from server instance to parser\n  if (typeof this.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = this.maxHeadersCount << 1;\n  } else {\n    // Set default value because parser may be reused from FreeList\n    parser.maxHeaderPairs = 2000;\n  }\n\n  socket.addListener('error', function(e) {\n    self.emit('clientError', e, this);\n  });\n\n  socket.ondata = function(d, start, end) {\n    assert(!socket._paused);\n    var ret = parser.execute(d, start, end - start);\n    if (ret instanceof Error) {\n      debug('parse error');\n      socket.destroy(ret);\n    } else if (parser.incoming && parser.incoming.upgrade) {\n      // Upgrade or CONNECT\n      var bytesParsed = ret;\n      var req = parser.incoming;\n\n      socket.ondata = null;\n      socket.onend = null;\n      socket.removeListener('close', serverSocketCloseListener);\n      parser.finish();\n      freeParser(parser, req);\n\n      // This is start + byteParsed\n      var bodyHead = d.slice(start + bytesParsed, end);\n\n      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n      if (EventEmitter.listenerCount(self, eventName) > 0) {\n        self.emit(eventName, req, req.socket, bodyHead);\n      } else {\n        // Got upgrade header or CONNECT method, but have no handler.\n        socket.destroy();\n      }\n    }\n\n    if (socket._paused) {\n      // onIncoming paused the socket, we should pause the parser as well\n      debug('pause parser');\n      socket.parser.pause();\n    }\n  };\n\n  socket.onend = function() {\n    var ret = parser.finish();\n\n    if (ret instanceof Error) {\n      debug('parse error');\n      socket.destroy(ret);\n      return;\n    }\n\n    if (!self.httpAllowHalfOpen) {\n      abortIncoming();\n      if (socket.writable) socket.end();\n    } else if (outgoing.length) {\n      outgoing[outgoing.length - 1]._last = true;\n    } else if (socket._httpMessage) {\n      socket._httpMessage._last = true;\n    } else {\n      if (socket.writable) socket.end();\n    }\n  };\n\n  socket.addListener('close', serverSocketCloseListener);\n\n  // The following callback is issued after the headers have been read on a\n  // new message. In this callback we setup the response object and pass it\n  // to the user.\n\n  socket._paused = false;\n  function socketOnDrain() {\n    // If we previously paused, then start reading again.\n    if (socket._paused) {\n      socket._paused = false;\n      socket.parser.resume();\n      readStart(socket);\n    }\n  }\n  socket.on('drain', socketOnDrain);\n\n  parser.onIncoming = function(req, shouldKeepAlive) {\n    incoming.push(req);\n\n    // If the writable end isn't consuming, then stop reading\n    // so that we don't become overwhelmed by a flood of\n    // pipelined requests that may never be resolved.\n    if (!socket._paused) {\n      var needPause = socket._writableState.needDrain;\n      if (needPause) {\n        socket._paused = true;\n        // We also need to pause the parser, but don't do that until after\n        // the call to execute, because we may still be processing the last\n        // chunk.\n        readStop(socket);\n      }\n    }\n\n    var res = new ServerResponse(req);\n\n    res.shouldKeepAlive = shouldKeepAlive;\n    ;\n    ;\n\n    if (socket._httpMessage) {\n      // There are already pending outgoing res, append.\n      outgoing.push(res);\n    } else {\n      res.assignSocket(socket);\n    }\n\n    // When we're finished writing the response, check if this is the last\n    // respose, if so destroy the socket.\n    res.on('finish', function() {\n      // Usually the first incoming element should be our request.  it may\n      // be that in the case abortIncoming() was called that the incoming\n      // array will be empty.\n      assert(incoming.length == 0 || incoming[0] === req);\n\n      incoming.shift();\n\n      // if the user never called req.read(), and didn't pipe() or\n      // .resume() or .on('data'), then we call req._dump() so that the\n      // bytes will be pulled off the wire.\n      if (!req._consuming)\n        req._dump();\n\n      res.detachSocket(socket);\n\n      if (res._last) {\n        socket.destroySoon();\n      } else {\n        // start sending the next message\n        var m = outgoing.shift();\n        if (m) {\n          m.assignSocket(socket);\n        }\n      }\n    });\n\n    if (req.headers.expect !== undefined &&\n        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&\n        continueExpression.test(req.headers['expect'])) {\n      res._expect_continue = true;\n      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {\n        self.emit('checkContinue', req, res);\n      } else {\n        res.writeContinue();\n        self.emit('request', req, res);\n      }\n    } else {\n      self.emit('request', req, res);\n    }\n    return false; // Not a HEAD response. (Not even a response!)\n  };\n}\nexports._connectionListener = connectionListener;\n\n// Legacy Interface\n\nfunction Client(port, host) {\n  if (!(this instanceof Client)) return new Client(port, host);\n  EventEmitter.call(this);\n\n  host = host || 'localhost';\n  port = port || 80;\n  this.host = host;\n  this.port = port;\n  this.agent = new Agent({ host: host, port: port, maxSockets: 1 });\n}\nutil.inherits(Client, EventEmitter);\nClient.prototype.request = function(method, path, headers) {\n  var self = this;\n  var options = {};\n  options.host = self.host;\n  options.port = self.port;\n  if (method[0] === '/') {\n    headers = path;\n    path = method;\n    method = 'GET';\n  }\n  options.method = method;\n  options.path = path;\n  options.headers = headers;\n  options.agent = self.agent;\n  var c = new ClientRequest(options);\n  c.on('error', function(e) {\n    self.emit('error', e);\n  });\n  // The old Client interface emitted 'end' on socket end.\n  // This doesn't map to how we want things to operate in the future\n  // but it will get removed when we remove this legacy interface.\n  c.on('socket', function(s) {\n    s.on('end', function() {\n      if (self._decoder) {\n        var ret = self._decoder.end();\n        if (ret)\n          self.emit('data', ret);\n      }\n      self.emit('end');\n    });\n  });\n  return c;\n};\n\nexports.Client = util.deprecate(Client,\n    'http.Client will be removed soon. Do not use it.');\n\nexports.createClient = util.deprecate(function(port, host) {\n  return new Client(port, host);\n}, 'http.createClient is deprecated. Use `http.request` instead.');\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"javascript","scrolltop":28668.5,"scrollleft":0,"selection":{"start":{"row":2069,"column":29},"end":{"row":2069,"column":29},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":2046,"state":"start","mode":"ace/mode/javascript"}}}