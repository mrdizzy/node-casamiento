{
  "name": "cacher",
  "version": "1.0.1",
  "description": "A memcached backed http cache in the form of express middleware",
  "main": "index.js",
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/addisonj/node-cacher.git"
  },
  "keywords": [
    "memcached",
    "cache",
    "middleware",
    "express",
    "http-caching"
  ],
  "author": {
    "name": "Addison Higham",
    "email": "addisonj@gmail.com",
    "url": "github.com/addisonj"
  },
  "license": "BSD",
  "dependencies": {
    "memory-cache": "0.0.5"
  },
  "devDependencies": {
    "mocha": "~1.10.0",
    "express": "~2.5.11",
    "supertest": "~0.6.0",
    "async": "~0.2.9"
  },
  "contributors": [
    {
      "name": "Addison Higham",
      "email": "addisonj@gmail.com",
      "url": "github.com/addisonj"
    },
    {
      "name": "Giovanni Cappellotto",
      "url": "github.com/potomak"
    }
  ],
  "readme": "## Cacher\nIt does the hard work so you don't have too!\n\n## What is it?\nHTTP Caching implemented as express middleware, with pluggable backends for support for a variety of caching servers (memcached, redis, etc)\n\n## Features\n- Set expiriry times per-app or per-route. It sets proper headers for client caching\n- Avoids the thundering heard by smartly refreshing the cache\n- Emits hit or miss events so you can track your hitrate\n- Simple invadlidations\n- Overrides for custom cache keys and dev mode support\n- Obeys (some) client Cache-Control headers\n\n## What does it look like?\n``` JavaScript\nvar Cacher = require(\"cacher\")\n// use the default in memory cache\nvar cacher = new Cacher()\n// or pass in a different cache client (in this cached memcached) for different backend support\nCacherMemcached = require('cacher-memcached')\nvar cacher = new Cacher(new CacherMemcached('host1:12345'))\n\n// as a global middleware\napp.use(cacher.cache('seconds', 30))\n// or per route\napp.get(\"/long-cache\", cacher.cache('days'), ...)\napp.get(\"/short-cache\", cacher.cache('minute'), ...)\n// will set no-cache headers for routes that we explicitly want to ignore caching on\napp.get(\"/no-cache\", cacher.cache(false), ...)\n\n// Backwards compatible with old cache definitions\napp.use(cacher.cacheHourly())\napp.get(\"/long-cache\", cacher.cacheDays(2), ...)\n\n// invalidation support\ncacher.invalidate('/home')\n\n// listen for events to track cache rate and errors\ncacher.on(\"hit\", function(key) {\n  console.log(\"woohoo!\")\n})\ncacher.on(\"miss\", function(key) {\n  console.log(\"doh!\")\n})\ncacher.on(\"error\", function(key) {\n  console.log(err)\n})\n\n// Dev mode, quickly turn off caching when it gets in the way\napp.configure('development', function() {\n  cacher.noCaching = true\n})\n\n// override cache key generation for finer grain control\ncacher.genCacheKey = function(req) {\n  return req.path + req.header('user-agent')\n}\n```\n\n## Backends\nCurrently, Cacher comes bundled with an in-memory cache\n\nBackends are distributed as seperated modules:\n- cacher-memcached (https://github.com/addisonj/cacher-memcached)\n- cacher-redis (https://github.com/addisonj/cacher-redis)\n\n\n## Backend Client Api\nIf you want to implement your own backend, the API is really simple:\n\n```JavaScript\n// pass whatever options are needed for connection/options\n// provide defaults so a client can be fully instantiated with no parameters\nfunction MyBackend(...) {\n}\n\n// cb is required, cb(err, cacheObject)\nMyBackend.prototype.get = function(key, cb) {}\n\nMyBackend.prototype.set = function(key, cacheObject, ttlInSeconds, [cb]) {}\n\nMyBackend.prototype.invaldaite = function(key, [cb]) {}\n```\n\n## Testing your backend\nRun unit tests using your backend by doing the following:\n```Shell\ncd Cacher\nnpm link ../myBackend\nCACHER_CLIENT=myBackend npm test\n```\n",
  "_id": "cacher@1.0.1",
  "dist": {
    "shasum": "b542ddf6738110c7fdafc0eeedad79e0de8b88e1"
  },
  "_from": "cacher"
}
